# リファクタリング設計書

## 1. 概要

本設計書は、現在のReactアプリケーションのコンポーネントを責務ごとに分割し、保守性と再利用性を向上させるためのリファクタリング計画を定義します。

## 2. 現状の課題

- App.tsxに複数の責務が混在
- コンポーネントの再利用性が低い
- ビジネスロジックとUIロジックの分離が不十分
- テストが書きにくい構造

## 3. リファクタリング方針

### 3.1 責務の分離原則

- **単一責任の原則（SRP）**: 各コンポーネントは1つの責務のみを持つ
- **関心の分離**: UI、ビジネスロジック、データ管理を明確に分離
- **再利用性**: 汎用的なコンポーネントは独立して再利用可能にする

### 3.2 ディレクトリ構造

```
src/
├── components/           # UIコンポーネント
│   ├── common/          # 共通コンポーネント
│   │   ├── Button/
│   │   ├── Input/
│   │   └── Modal/
│   ├── layout/          # レイアウトコンポーネント
│   │   ├── Header/
│   │   ├── Footer/
│   │   └── Sidebar/
│   └── features/        # 機能別コンポーネント
│       ├── auth/        # 認証関連
│       ├── dashboard/   # ダッシュボード
│       └── settings/    # 設定画面
├── hooks/               # カスタムフック
│   ├── useAuth.ts
│   ├── useApi.ts
│   └── useForm.ts
├── services/            # APIとの通信、外部サービス
│   ├── api/
│   └── storage/
├── store/               # 状態管理
│   ├── slices/
│   └── index.ts
├── types/               # 型定義
│   ├── models/
│   └── interfaces/
├── utils/               # ユーティリティ関数
│   ├── validators/
│   └── formatters/
└── styles/              # グローバルスタイル
    ├── theme/
    └── globals.css
```

## 4. コンポーネント分割設計

### 4.1 コンポーネントの分類

#### Presentational Components（表示コンポーネント）
- 責務: UIの表示のみ
- 特徴:
  - propsを通じてデータを受け取る
  - 状態を持たない（またはUIに関する状態のみ）
  - 純粋関数として実装可能

#### Container Components（コンテナコンポーネント）
- 責務: ビジネスロジックとデータ管理
- 特徴:
  - データの取得・更新を管理
  - 複数のPresentationalコンポーネントを組み合わせる
  - グローバルな状態管理との接続

#### Page Components（ページコンポーネント）
- 責務: ルーティングの終端となるコンポーネント
- 特徴:
  - 複数のContainer/Presentationalコンポーネントを組み合わせる
  - ページ全体のレイアウトを定義

### 4.2 具体的な分割例

```typescript
// Before: App.tsx（全ての責務が混在）
const App = () => {
  // 状態管理、API通信、UI表示が全て混在
}

// After: 責務ごとに分割

// 1. データ取得用Hook
// hooks/useUserData.ts
const useUserData = () => {
  // データ取得ロジック
}

// 2. Presentationalコンポーネント
// components/common/UserCard/UserCard.tsx
const UserCard = ({ user }) => {
  // 表示のみ
}

// 3. Containerコンポーネント
// components/features/users/UserList.tsx
const UserList = () => {
  const { users, loading } = useUserData();
  // ビジネスロジック
  return <UserCard user={user} />
}

// 4. Pageコンポーネント
// pages/UsersPage.tsx
const UsersPage = () => {
  return (
    <Layout>
      <UserList />
    </Layout>
  );
}
```

## 5. リファクタリング実施計画

### Phase 1: 基盤整備（1週目）
- [ ] ディレクトリ構造の作成
- [ ] 型定義の整理
- [ ] ユーティリティ関数の抽出

### Phase 2: コンポーネント分割（2-3週目）
- [ ] 共通コンポーネントの抽出
- [ ] レイアウトコンポーネントの作成
- [ ] 機能別コンポーネントへの分割

### Phase 3: ロジック分離（4週目）
- [ ] カスタムフックの作成
- [ ] API層の実装
- [ ] 状態管理の統合

### Phase 4: 最適化（5週目）
- [ ] パフォーマンス最適化
- [ ] コード品質の改善
- [ ] テストの追加

## 6. 品質基準

### 6.1 コード品質
- ESLintルールの遵守
- TypeScriptの厳格な型チェック
- コンポーネントごとのユニットテスト

### 6.2 パフォーマンス
- React.memoによる不要な再レンダリング防止
- 遅延ロードの実装
- バンドルサイズの最適化

### 6.3 保守性
- 明確な命名規則
- 適切なコメント
- Storybookによるコンポーネントドキュメント

## 7. 期待される効果

1. **開発効率の向上**
   - コンポーネントの再利用による開発スピード向上
   - 責務が明確になることでバグの減少

2. **保守性の向上**
   - 変更の影響範囲が限定的
   - テストしやすい構造

3. **チーム開発の効率化**
   - 責務が明確になることで並行開発が可能
   - コードレビューが容易

## 8. リスクと対策

### リスク
- リファクタリング中の機能停止
- 既存機能へのデグレード

### 対策
- 段階的なリファクタリング
- 十分なテストカバレッジの確保
- フィーチャーフラグによる段階的リリース

## 9. 成功指標

- コンポーネントの再利用率: 30%以上
- テストカバレッジ: 80%以上
- ビルド時間の短縮: 20%削減
- 新機能開発時間: 30%短縮